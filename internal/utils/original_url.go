package utils

import (
	"crypto/sha256"
	"encoding/hex"
	"errors"
	"net"
	"net/url"
	"strings"
)

// isValidURL performs basic safety and format validation to
// protect the URL shortener from invalid or malicious URLs
func isValidURL(rawURL string) bool {
	// Parse URL and ensure it's syntactically valid
	u, err := url.ParseRequestURI(rawURL)
	if err != nil {
		return false
	}

	// Only allow http or https schemes
	if u.Scheme != "http" && u.Scheme != "https" {
		return false
	}

	// URL must contain a host component
	if u.Host == "" {
		return false
	}

	// Resolve host to IP addresses
	ips, err := net.LookupIP(u.Host)
	if err != nil {
		return false
	}

	// Block internal, loopback, or private IP ranges
	// Prevents SSRF(Server-Side Request Forgery) attacks
	for _, ip := range ips {
		if ip.IsLoopback() || ip.IsPrivate() {
			return false
		}
	}

	// All checks passed â†’ URL seems valid and safe
	return true
}

// ValidateURL checks whether a given URL is valid or not
func ValidateURL(rawURL string) error {
	if !isValidURL(rawURL) {
		return errors.New("Invalid or unsafe URL")
	}
	return nil
}

// ExtractShortCode extracts the short code from a Short URL
// that has been generated by this URL Shortener service
func ExtractShortCode(rawURL string) (string, error) {
	u, err := url.Parse(rawURL)
	if err != nil {
		return "", err
	}
	return strings.TrimPrefix(u.Path, "/"), nil
}

// HashURL returns an SHA-256 hash of the URL as a hex string
// Safe for use in Redis keys and database storage
func HashURL(rawURL string) string {
	hash := sha256.Sum256([]byte(rawURL))
	return hex.EncodeToString(hash[:])
}
